# pythonProject
[项目地址](https://github.com/wulx1/pythonProject)
###wulx python学习笔记

```python
print("hello")
```
###面向对象编程
• Object Oriented Programming，简称 OOP，是一种程序设计思想
• OOP 把对象作为程序的基本单元，一个对象包含了数据和操作数据的方法
 
Python里面有一句话：万物皆是对象
在编程领域中，通常把现实世界中的实体称为对象，例如：
• 美国总统特朗普
• 中国明星成龙
• 上海中心大厦
• 北京中信大厦
对象指的是一个具体的实体，不用于指代一个抽象的群体
行为又被称为方法，它是对属性的操作
包括读取操作和修改操作，例如，在特朗普的自我介绍行为中，会读取他的属性：姓名和年龄

Python 类
类定义语法
最简单的类定义看起来像这样
```python
class ClassName:
    <statement-1>
    .
    .
    .
    <statement-N>
```
类定义与函数定义 (def 语句) 一样必须被调用执行才会起作用
 
类命名空间
• 当定义类时，会创建一个新的命名空间，也是一个局部作用域
• 上面的类定义栗子里，statement-1 到 statement-N 就是这个类的命名空间
 
类的取名建议规则
类名中的所有单词首字母要大写，采用驼峰命名法（例 GameCase ）的书写方式
 
最简单的一个类
```python
classDog:
    pass
• 这个类没有属性也没有方法
• 实际应用中，很少会创建空类，因为空类没有任何实际意义
self 参数

classPoloBlog:def__init__(self):
        ...
defsay(self):
        ...

 在类里面，所有实例方法都需要加 self 参数，且排在第一个，有且仅有一个
 
self 参数的含义
在类中定义的方法，第一个参数 self 指向调用该方法的实例对象，在方法中通过  self.属性 这样的形式访问对象的实例属性
 
self 参数真的必须叫 self 吗
• 其实并不是哦
• Python 只是规定，无论是构造方法还是实例方法，最少要包含一个参数，并没有规定该参数的具体名称
• 之所以将其命名为 self，只是约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性，大家一看到 self，就知道它的作用
• 你想叫 test也可以

只是可读性很差
 
如何理解 self 参数 
类比
• 如果把类比作造房子的图纸
• 类实例化后的对象是真正可以住的房子
• 根据一张图纸（类），可以设计出成千上万的房子（实例对象）
• 每个房子长相都是类似的（都有相同的实例属性和实例方法），但它们都有各自的主人
• 如何区分不同的房子：通过 self 参数，可以保证每个房子的主任仅能进入自己的房子（每个实例对象只能调用自己的实例属性和实例方法）
 
重点
• 一个类可以产生多个实例对象，当某个实例对象调用实例方法，该对象会把自身的引用作为第一个参数自动传递给该方法
• 换句话说：Python 会自动将实例方法的第一个参数指向调用该方法的对象
• 这样，Python 解释器就知道到底要执行哪个对象的实例方法了
• 调用实例方法的时候，不需要手动为第一个参数传值
 
类变量、实例变量/类属性、实例属性
前言
只是叫法不一样
实例属性 = 实例变量
类属性 = 类变量
个人认为叫属性更恰当
 
类属性和实例属性区别
• 类属性，所有实例对象共享该属性
• 实例属性，属于某一个实例对象的属性，用于描述具体的对象

类属性的调用方式
有两种
• 直接通过类名调用
• 也可以通过类的实例对象调用
动态添加类属性
• age 没有在类体中定义
• 可以直接通过 类名.new_property_name 的方式定义一个新的类属性
实例属性 
• 属于具体对象的属性，用于描述具体的对象
• 只能通过实例对象访问，无法通过类名访问
• 

不推荐实例属性和类属性同名
• 类中，实例属性和类属性可以同名
• 但这种情况下使用实例对象将无法调用类变量，它会首选实例变量，无论这个变量是否已定义
• 实例独享绑定新的实例属性时，会直接覆盖掉重名的类属性
• 实例属性、类属性同名例子：
• 


实例方法
在类中定义的方法默认都是实例方法


类方法
类方法和实例方法很相似，又很不相似
 
相似点
• 也至少要包含一个参数，不过通常命名为 cls
• 在调用类方法时，无需显式为 cls 参数传参，但传递的并不是实例对象，而是类对象本身
 
不同点
最大的不同在于需要使用 @classmethod 装饰器才能称为类方法
实际例子：


类方法可以调用实例方法吗？
可以，但有局限性


• 类方法调用实例方法的方式： cls.实例方法(cls) ，通过 cls 调用，且还要传递 cls 为参数
• 从 id 相同即可看出，实例方法接收的仍然是一个类对象

实例对象可以调用类方法吗？
可以，但不建议


• t是一个实例对象，且初始化赋值了 sum 实例属性
• 但最后实例方法打印的仍然是 sum 类属性，表明类方法无法访问实例属性
• 且 cls、self 参数的 id 和上面的栗子完全一样，表明即使通过实例对象调用类方法，传递的仍然是类对象的引用，所有类方法都被同一个类对象调用，一个类只有一个类对象

实例方法可以调用类属性吗？
可以，但不能通过实例对象调用，只能通过类对象

扩展思考题！
• 一个方法内部既需要访问实例属性，又需要访问类属性，应该定义为什么方法？
• 答案：实例方法，因为可以通过 类对象.类属性 来访问，但在类方法中无法访问实例属性
代码栗子直接看上面一个就是啦！
 
静态方法
• 和之前学过的函数一毛一样，唯一区别是：静态方法需要定义在类体中，且需要添加 @staticmethod 装饰器
• 静态方法没有 self、cls 参数，也不需要至少传一个参数，和普通函数一样
• Python 解释器不会对它包含的参数做任何类或对象的绑定，所以静态方法无法调用任何类属性、类方法、实例属性、实例方法，除非通过类名和实例对象
 
什么时候会用静态方法
类里面封装的方法
• 既不需要访问实例属性、实例方法
• 也不需要访问类属性、类方法
就可以考虑将这个方法封装成一个静态方法


关于实例方法、 classmethod 和 staticmethod 的实际应用场景
简单来说
• 实例方法：方法内部需要访问实例属性、实例方法就定义为实例方法；既需要访问实例属性、方法，也需要访问类属性、方法，那必须定义为实例方法
• 类方法：方法内部只需要访问类属性、类方法就定义为类方法
• 静态方法：方法内部既不需要访问实例属性、实例方法，也不需要访问类属性、类方法就定义为静态方法

为什么要讲 __str__
• 在 Python 中，直接 print 一个实例对象，默认是输出这个对象由哪个类创建的对象，以及在内存中的地址（十六进制表示）
• 假设在开发调试过程中，希望使用 print 实例对象时，输出自定义内容，就可以用 __str__ 方法了
• 或者通过 str() 调用对象也会返回 __str__ 方法返回的值

公共属性
在 Python 的类里面，所有属性和方法默认都是公共的
私有类型的属性、方法
• 在实际开发中，对象的某些属性或方法可能只希望在对象的内部被使用，而不希望在外部被访问到
• 私有属性：就是对象不希望公开访问的属性
• 私有方法：就是对象不希望公开访问的方法
• 可以通过公共方法访问私有属性
• 

重点
• 子类无法访问父类的私有变量、方法
• 私有变量只有本类的内部能直接调用
• But！外部真的不能访问吗？
伪私有属性和私有方法
• 其实 Python 中，并没有真正意义上的私有，仍然可以在外部访问私有属性、私有方法
• 因为，在给私有属性、方法命名时，实际是对名称做了一些特殊处理，使得外界无法访问到
• 处理方式：在名称前面加上 _类名 ，私有属性、方法就会变成  _类名__名称 

 unittest简单介绍
单元测试框架
还可以适用WEB自动化测试用例的开发与执行
提供丰富的断言方法
官方文档：https://docs.python.org/zh-cn/3/library/unittest.html

这里包含的知识点：

unittest.Testcase 
自己创建的单元测试类都要继承它，它是所有单元测试类的基类
 

setUp 
用于每个测试用例执行前的初始化工作
所有类中方法的入参为 self ，定义实例变量也要 self.变量 
 

tearDown 
每个测试用例执行后的都会执行此方法
 

setUpClass 
每个单元测试类运行前调用该方法，只会执行一次
属于类方法，需要加上装饰器 @classmethod 
默认入参是 cls ，指的就是“类对象”本身，其实和self没什么区别，用法一致
 

tearDownClass 
每个单元测试类运行后调用该方法，只会执行一次
属于类方法，需要加上装饰器 @classmethod 
 

测试用例
必须以“test_”开头命名的方法，否则无法识别并执行
方法里面需要有断言，才能在最后运行时有该用例的执行结果
可包含多个测试用例
 

unittest.main()
运行单元测试
该命令会搜索当前module 下所有以 test开头的测试用例，并运行它们
执行顺序是按照case的命名

跳过执行测试用例共有四种写法
 @unittest.skip(reason) ：跳过测试用例，reason  为测试被跳过的原因
 @unittest.skipIf(condition, reason) ：当 condition 为真时，跳过测试用例。
 @unittest.skipUnless(condition, reason) ：跳过测试用例，除非 condition 为真
 @unittest.expectedFailure ：把测试用例标记为预计失败；如果测试不通过，会被认为测试成功；如果测试通过了，则被认为是测试失败
 

self.skipTest(reason) 
在方法体内满足某些条件下才跳过执行该测试用例

 

跳过执行测试用例注意点
被跳过的测试的  setUp() 和  tearDown()  不会被运行
只输入 unittest.skip ，也可以正常跳过，不必写reason
若输入 unittest.skip() ，括号内必须写reason，不得为空
可以针对单元测试类级别设置跳过执行（在class声明上面直接加装饰器即可），该单元测试类所有测试用例不会被执行
被跳过的类的 setUpClass() 和 tearDownClass() 不会被运行
当方法体内调用了 self.skipTest(reason) 方法，该测试用例还是会调用 setUp() 和 tearDown() 

test suite 
测试套件，理解成测试用例集
一系列的测试用例，或测试套件，理解成测试用例的集合和测试套件的集合
当运行测试套件时，则运行里面添加的所有测试用例
 

test runner 
测试运行器
用于执行和输出结果的组件 

包含知识点
使用测试套件时，测试用例的执行顺序可以自定义，按照添加的顺序执行
有两种添加测试用例的方式，推荐方式二，代码更少更快捷
addTests(tests) ，传入的 tests 可以是list、tuple、set
添加的测试用例格式是：单元测试类名(测试用例名) 
使用测试套件执行测试用例的大致步骤是：实例化TestSuite - 添加测试用例 - 实例化TextTestRunner - 运行测试套件
测试套件也可以添加测试套件

mock简介
py3已将mock集成到unittest库中
为的就是更好的进行单元测试
简单理解，模拟接口返回参数
通俗易懂，直接修改接口返回参数的值
官方文档：https://docs.python.org/zh-cn/3/library/unittest.mock.html
 

mock作用
解决依赖问题，达到解耦作用
当我们测试某个目标接口（模块）时，该接口依赖其他接口，当被依赖的接口未开发完成时，可以用mock模拟被依赖接口，完成目标接口的测试

 

模拟复杂业务的接口
当我们测试某个目标接口（模块），该接口依赖一个非常复杂的接口时，可以用mock来模拟这个复杂的业务接口；也解决接口依赖一样的原理

 

单元测试
如果某个接口（模块）未开发完成时，又需要编写测试用例，则可以通过mock模拟该接口（模块）进行测试

 

前后端联调
前端开发的页面需要根据后端返回的不同状态码展示不同的页面，当后端接口未开发完成时，也可通过mock来模拟后端接口返回自己想要的数据

 如果你还想从头学起Pytest，可以看看这个系列的文章哦！

https://www.cnblogs.com/poloyy/category/1690628.html

 

前言
目前有两种纯测试的测试框架，pytest和unittest
unittest应该是广为人知，而且也是老框架了，很多人都用来做自动化，无论是UI还是接口
pytest是基于unittest开发的另一款更高级更好用的单元测试框架
出去面试也好，跟别人说起来也好，pytest的逼格明显高于unittest
 

为什么要用Pytest
pytest 的官方网站介绍，它具有如下特点：
非常容易上手，入门简单，文档丰富，文档中有很多实例可以参考
能够支持简单的单元测试和复杂的功能测试
支持参数化
执行测试过程中可以将某些测试跳过（skip），或者对某些预期失败的case标记成失败
支持重复执行(rerun)失败的 case
支持运行由 nose, unittest 编写的测试 case
可生成 html 报告
方便的和持续集成工具 jenkins 集成
可支持执行部分用例
具有很多第三方插件，并且可以自定义扩展
